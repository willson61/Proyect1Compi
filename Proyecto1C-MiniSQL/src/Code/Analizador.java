/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package Code;

import java.util.List;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.Reader;
import java.io.RandomAccessFile;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import java_cup.runtime.Symbol;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.filechooser.FileNameExtensionFilter;

/**
 *
 * @author Sthephan
 */
public class Analizador extends javax.swing.JFrame {

    /**
     * Creates new form Analizador
     */
    public List<TokenElement> ListaTokens;
    public TokenElement TokenActual;
    public int Puntero = -1;
    public SintaxisError Error;
    public StringBuilder salida; 
    
    public Analizador() {
        initComponents();
        this.setLocationRelativeTo(this);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        lblRutaEntrada = new javax.swing.JLabel();
        btnEntrada = new javax.swing.JButton();
        btnAnalizar = new javax.swing.JButton();
        btnBorrar = new javax.swing.JButton();
        btnGenerar = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        TextArea1 = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        lblRutaEntrada.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N

        btnEntrada.setText("Buscar Entrada");
        btnEntrada.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnEntradaActionPerformed(evt);
            }
        });

        btnAnalizar.setText("Analizar Entrada");
        btnAnalizar.setEnabled(false);
        btnAnalizar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnAnalizarActionPerformed(evt);
            }
        });

        btnBorrar.setText("Borrar Entrada");
        btnBorrar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnBorrarActionPerformed(evt);
            }
        });

        btnGenerar.setText("Generar Lexer");
        btnGenerar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnGenerarActionPerformed(evt);
            }
        });

        TextArea1.setColumns(20);
        TextArea1.setRows(5);
        jScrollPane1.setViewportView(TextArea1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(btnEntrada)
                                .addGap(18, 18, 18)
                                .addComponent(btnBorrar)
                                .addGap(18, 18, 18)
                                .addComponent(btnGenerar))
                            .addComponent(lblRutaEntrada)
                            .addComponent(btnAnalizar))
                        .addGap(0, 35, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(17, 17, 17)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(btnEntrada)
                    .addComponent(btnBorrar)
                    .addComponent(btnGenerar))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(lblRutaEntrada)
                .addGap(43, 43, 43)
                .addComponent(btnAnalizar)
                .addGap(18, 18, 18)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 255, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnEntradaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnEntradaActionPerformed
        JFileChooser dialogo = new JFileChooser();
        FileNameExtensionFilter filtro = new FileNameExtensionFilter("Archivo de Texto", "txt");
        File ficheroImagen;
        String rutaArchivo;
        //dialogo.setFileFilter(filtro);
        int valor = dialogo.showOpenDialog(this);
        if (valor == JFileChooser.APPROVE_OPTION) 
        {
            ficheroImagen = dialogo.getSelectedFile();
            rutaArchivo = ficheroImagen.getPath();
            lblRutaEntrada.setText(rutaArchivo);
            btnAnalizar.setEnabled(true);
            btnEntrada.setEnabled(false);
        }
    }//GEN-LAST:event_btnEntradaActionPerformed

    private void btnAnalizarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnAnalizarActionPerformed
        String resultado = "";
        boolean estado = true;
        File lex = new File("C:/Users/Sthephan/Documents/GitHub/Proyect1Compi/Proyecto1C-MiniSQL/src/Code/Lexer.java");
        File entrada = new File(lblRutaEntrada.getText());
        if(lex.exists()){
            try {
                int lenghtToken = 0;
                int posInicial = 0;
                int posFinal = 0;
                int numLinea = 0;
                int numErrors = 0;
                Reader lector = new BufferedReader(new FileReader(lblRutaEntrada.getText()));
                Lexer lexer = new Lexer(lector);
                while (estado) {
                    Tokens tokens = lexer.yylex();
                    if (tokens == null) {
                        resultado += "FIN";
                        estado = false;
                    }
                    else{
                        lenghtToken = lexer.yylength();
                        posFinal = posFinal + lenghtToken;
                        numLinea = lexer.lin;
                        switch (tokens) {
                            case ERROR:
                                    resultado += "Simbolo no definido\n";
                                    numErrors = numErrors + 1;
                                    break;
                            case Identificador:
                                if(lenghtToken > 31){
                                    resultado += "ERROR: El Identificador: " + lexer.lexeme.substring(0, 32) + " excedio el limite de caracteres en, Linea: " + numLinea + " , Posicion Inicial: " + posInicial + " , Posicion Final: " + posFinal + "\n";
                                    numErrors = numErrors + 1;
                                }
                                else{
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea + " , Posicion Inicial: " + posInicial + " , Posicion Final: " + posFinal + "\n";
                                }                   
                                break;
                            case ADD:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case EXTERNAL:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case PROCEDURE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case ALL:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case OUT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case READONLY:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case ENCRYPTION:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case RETURNS:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case SCHEMABINDING:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case CALLED:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case INLINE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case CALLER:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case SELF:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case OWNER:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case RECOMPILE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case MARK:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case FORWARDONLY:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case STATIC:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case KEYSET:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case DYNAMIC:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case FASTFORWARD:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case READ_ONLY:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case SCROLL_LOCKS:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case OPTIMISTIC:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case TYPE_WARNING:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case FETCH:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case PUBLIC:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case ALTER:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case FILE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case RAISERROR:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case AND:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case FILLFACTOR:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case READ:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case ANY:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case FOR:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case READTEXT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case TYPEWARNING:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case AS:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case FOREIGN:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case RECONFIGURE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case ASC:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case FREETEXT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case REFERENCES:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case AUTHORIZATION:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case FREETEXTTABLE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case REPLICATION:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case BACKUP:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case FROM:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case RESTORE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case BEGIN:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case FULL:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case RESTRICT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case BETWEEN:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case FUNCTION:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case RETURN:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case BREAK:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case GOTO:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case REVERT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case BROWSE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case GRANT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case REVOKE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case BULK:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case GROUP:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case RIGHT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case BY:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case HAVING:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case ROLLBACK:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case CASCADE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case HOLDLOCK:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case ROWCOUNT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case CASE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case IDENTITY:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case ROWGUIDCOL:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case CHECK:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case IDENTITY_INSERT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case RULE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case CHECKPOINT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case IDENTITYCOL:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case SAVE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case CLOSE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case IF:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case SCHEMA:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case CLUSTERED:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case IN:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case SECURITYAUDIT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case COALESCE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case INDEX:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case SELECT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case COLLATE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case INNER:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case SEMANTICKEYPHRASETABLE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case COLUMN:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case INSERT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case SEMANTICSIMILARITYDETAILSTABLE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case COMMIT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case INTERSECT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case SEMANTICSIMILARITYTABLE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case COMPUTE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case INTO:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case SESSION_USER:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case CONSTRAINT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case IS:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case SET:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case CONTAINS:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case JOIN:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case SETUSER:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case CONTAINSTABLE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case KEY:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case SHUTDOWN:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case CONTINUE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case KILL:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case SOME:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case CONVERT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case LEFT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case STATISTICS:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case CREATE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case LIKE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case SYSTEM_USER:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case CROSS:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case LINENO:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case TABLE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case CURRENT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case LOAD:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case TABLESAMPLE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case CURRENT_DATE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case MERGE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case TEXTSIZE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case CURRENT_TIME:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case NATIONAL:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case THEN:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case CURRENT_TIMESTAMP:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case NOCHECK:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case TO:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case CURRENT_USER:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case NONCLUSTERED:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case TOP:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case CURSOR:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case NOT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case TRAN:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case DATABASE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case NULL:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case TRANSACTION:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case DBCC:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case NULLIF:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case TRIGGER:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case DEALLOCATE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case OF:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case TRUNCATE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case DECLARE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case OFF:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case TRY_CONVERT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case DEFAULT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case OFFSETS:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case TSEQUAL:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case DELETE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case ON:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case UNION:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case DENY:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case OPEN:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case UNIQUE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case DESC:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case OPENDATASOURCE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case UNPIVOT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case DISK:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case OPENQUERY:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case UPDATE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case DISTINCT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case OPENROWSET:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case UPDATETEXT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case DISTRIBUTED:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case OPENXML:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case USE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case DOUBLE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case OPTION:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case USER:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case DROP:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case OR:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case VALUES:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case DUMP:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case ORDER:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case VARYING:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case ELSE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case OUTER:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case VIEW:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case END:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case OVER:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case WAITFOR:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case ERRLVL:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case PERCENT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case WHEN:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case ESCAPE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case PIVOT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case WHERE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case EXCEPT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case PLAN:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case WHILE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case EXEC:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case PRECISION:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case WITH:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case EXECUTE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case PRIMARY:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case WITHINGROUP:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case EXISTS:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case PRINT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case WRITETEXT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case EXIT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case PROC:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case INCLUDE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case IMMEDIATE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case GO:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case SUM:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case AVG:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case COUNT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case MAX:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case MIN:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case KB:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case GB:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case TB:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case MB:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case BIGINT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case INT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case SMALLINT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case TINYINT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case BIT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case DECIMAL:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case MONEY:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case NUMERIC:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case SMALLMONEY:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case FLOAT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case REAL:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case DATE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case DATETIME:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case DATETIME2:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case DATETIMEOFFSET:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case SMALLDATETIME:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case TIME:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case CHAR:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case TEXT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case VARCHAR:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case NCHAR:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case NTEXT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case NVARCHAR:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case BINARY:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case IMAGE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case VARBINARY:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case FILENAME:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case NAME:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case NAMES:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case SIZE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case MAXSIZE:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case FILEGROWTH:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case UNLIMITED:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case OUTPUT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case INPUT:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case LOCAL:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case GLOBAL:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case SCROLL:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case SCROLLLOCKS:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Suma:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Resta:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Mul:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Div:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Porce:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case PuntoYComa:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Coma:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Punto:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Acorchete:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Ccorchete:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Aparentesis:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Cparentesis:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Allave:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Cllave:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Dcorchete:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Dparentesis:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Dllaves:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Arroba:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Hashtag:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Dhashtag:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Menor:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case MenorIgual:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Mayor:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case MayorIgual:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Digual:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Diferente:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Dampersand:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Dbarra:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Exclamacion:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Igual:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Varchar:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case VarcharError:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Float:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Integer:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case IdentificadorError:
                                    resultado += "ERROR: El identificador : " + lexer.lexeme + " no puede comenzar con numero o guion bajo. Posicion de Error: " + "Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    numErrors = numErrors + 1;
                                    break;
                            case Bit:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea +  ", Posicion Inicial: " + posInicial + ", Posicion Final: " + posFinal + "\n";
                                    break;
                            case Comentario:
                                    resultado += lexer.lexeme + ": Es un " + tokens + ", Linea: " + numLinea + " , Posicion Inicial: " + posInicial + " , Posicion Final: " + posFinal + "\n";
                                    break;
                            case ComentarioError:
                                    resultado += "ERROR: El comentario : " + lexer.lexeme + " no esta finalizado con */. Posicion de Error: " + "Linea: " + numLinea + " , Posicion Inicial: " + posInicial + " , Posicion Final: " + posFinal + "\n";
                                    numErrors = numErrors + 1;
                                    break;
                        }
                        posInicial = posFinal + 1;
                    }
                }
            } catch (FileNotFoundException ex) {
                Logger.getLogger(Analizador.class.getName()).log(Level.SEVERE, null, ex);
            } catch (IOException ex) {
                Logger.getLogger(Analizador.class.getName()).log(Level.SEVERE, null, ex);
            }
            String arch = entrada.getName().replace(".sql", ".out");
            File archivo = new File("C:/Users/Sthephan/Documents/GitHub/Proyect1Compi/" + arch);
            PrintWriter writer;
            try {
                if(archivo.exists() == false){
                    archivo.createNewFile();
                }
                else{
                    writer = new PrintWriter(archivo);
                    writer.print("");
                    writer.close();
                }
            } catch (IOException ex) {
                Logger.getLogger(Analizador.class.getName()).log(Level.SEVERE, null, ex);
            }
            PrintWriter escribir;
            try {
                escribir = new PrintWriter(archivo);
                escribir.print(resultado);
                escribir.close();
            } catch (FileNotFoundException ex) {
                Logger.getLogger(Analizador.class.getName()).log(Level.SEVERE, null, ex);
            }
            JOptionPane.showMessageDialog(null, "InfoBox: " + "Analisis Completo", "Estado", JOptionPane.INFORMATION_MESSAGE);
        }
        else{
            JOptionPane.showMessageDialog(null, "InfoBox: " + "No se ha generado el archivo Lexer.java para la ejecucion", "Estado", JOptionPane.INFORMATION_MESSAGE);
        }
        /*TokenElement el;
        ListaTokens = new ArrayList();
        String datos[] = resultado.split("\\n");
        for (int i = 0; i < datos.length; i++) {
            el = new TokenElement();
            el = TokenElement.TokFromText(datos[i]);
            if(!(el.getValor() == null)){
                ListaTokens.add(el);
            }
        }
        salida = new StringBuilder();
        salida.append(Error.getMensaje()); 
        salida.append("\n");
        Puntero = Puntero + BuscarFin(Puntero);
        TokenActual = ListaTokens.get(Puntero);
        Puntero = Puntero + 1;
        TokenActual = ListaTokens.get(Puntero);
        while(Puntero < ListaTokens.size()){
            Error = null;
            Inicio();
        }
        JOptionPane.showMessageDialog(null, "InfoBox: " + "Analisis Sintactico Terminado", "Estado", JOptionPane.INFORMATION_MESSAGE);
        TextArea1.setText(salida.toString());
        if(TextArea1.getText().equals("")){
            TextArea1.setText("No hay errores sintacticos");
        }*/
        Reader lector;
        String errors = "";
        try {
            lector = new BufferedReader(new FileReader(lblRutaEntrada.getText()));
            Sintax s = new Sintax(new Code.LexerCup(lector));
            try {
                s.parse();
                errors = s.obtenerErrores();
                if(errors.length() > 0){
                    TextArea1.setText(s.obtenerErrores());
                }
                else{
                    TextArea1.setText("Analisis Exitoso :)");
                }
            } catch (Exception ex) {
                Logger.getLogger(Analizador.class.getName()).log(Level.SEVERE, null, ex);
            }
        } catch (FileNotFoundException ex) {
            Logger.getLogger(Analizador.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_btnAnalizarActionPerformed

    private void btnGenerarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnGenerarActionPerformed
        String ruta = "C:/Users/Sthephan/Documents/GitHub/Proyect1Compi/Proyecto1C-MiniSQL/src/Code/Lexer.flex";
        generarLexer(ruta);
        this.dispose();
        JOptionPane.showMessageDialog(null, "InfoBox: " + "Lexer generado exitosamente, por favor vuelva a correr la aplicacion", "Estado", JOptionPane.INFORMATION_MESSAGE);
    }//GEN-LAST:event_btnGenerarActionPerformed

    private void btnBorrarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnBorrarActionPerformed
        lblRutaEntrada.setText("");
        btnEntrada.setEnabled(true);
        btnAnalizar.setEnabled(false);
    }//GEN-LAST:event_btnBorrarActionPerformed

    public static void generarLexer(String ruta){
        File archivo = new File(ruta);
        jflex.Main.generate(archivo);
    }
    
    public void ReadNextTokenElement(Tokens siguiente, String valor){
        if(TokenActual.evaluarToken(siguiente, valor)){
            Puntero = Puntero + 1;
            if(Puntero < ListaTokens.size())
                TokenActual = ListaTokens.get(Puntero);
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement(valor, siguiente));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public int BuscarFin(int puntero){
        TokenElement temp;
        int cont = 0;
        for (int i = puntero; i < ListaTokens.size(); i++) {
            temp = ListaTokens.get(i);
            if(!(temp.getValor().equals(";") || temp.getValor().equals("GO"))){
                cont = cont + 1;
            }
            else{
                return cont;
            }
        }
        return cont;
    }
    
    public void Inicio(){
        Inicio2();
        Fin();
        
    }
    
    public void Inicio2(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "ALTER")){
            Alter();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "CREATE")){
            Create();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "DELETE")){
            Delete();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "DROP")){
            Drop();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "TRUNCATE")){
            Truncate();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "INSERT")){
            Insert();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "UPDATE")){
            Update();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "SELECT")){
            Select();
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement("ALTER", Tokens.Reservada));
            elementos.add(new TokenElement("CREATE", Tokens.Reservada));
            elementos.add(new TokenElement("DELETE", Tokens.Reservada));
            elementos.add(new TokenElement("DROP", Tokens.Reservada));
            elementos.add(new TokenElement("TRUNCATE", Tokens.Reservada));
            elementos.add(new TokenElement("INSERT", Tokens.Reservada));
            elementos.add(new TokenElement("UPDATE", Tokens.Reservada));
            elementos.add(new TokenElement("SELECT", Tokens.Reservada));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void Fin(){
        if(TokenActual.evaluarToken(Tokens.Operador, ";")){
            ReadNextTokenElement(Tokens.Operador, ";");
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "GO")){
            ReadNextTokenElement(Tokens.Reservada, "GO");
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement(";", Tokens.Operador));
            elementos.add(new TokenElement("GO", Tokens.Reservada));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void ID(){
        if(TokenActual.evaluarToken(Tokens.Identificador, null)){
            ReadNextTokenElement(Tokens.Identificador, null);
        }
        else if(TokenActual.evaluarToken(Tokens.Operador, "[")){
            ReadNextTokenElement(Tokens.Operador, "[");
            if(Error == null)
                ReadNextTokenElement(Tokens.Identificador, null);
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, "]");
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement(null, Tokens.Identificador));
            elementos.add(new TokenElement("[", Tokens.Operador));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void IDL1(){
        ID();
        if(Error == null)
            IDL2();
    }
    
    public void IDL2(){
        if(TokenActual.evaluarToken(Tokens.Operador, ".")){
            ReadNextTokenElement(Tokens.Operador, ".");
            if(Error == null)
                ID();
        }
    }
    
    public void IDL3(){
        ID();
        if(Error == null)
            IDL4();
    }
    
    public void IDL4(){
        if(TokenActual.evaluarToken(Tokens.Operador, ".")){
            ReadNextTokenElement(Tokens.Operador, ".");
            if(Error == null)
                IDL1();
        }
    }
    
    public void IDL5(){
        ID();
        if(Error == null)
            IDL6();
    }
    
    public void IDL6(){
        if(TokenActual.evaluarToken(Tokens.Operador, ".")){
            ReadNextTokenElement(Tokens.Operador, ".");
            if(Error == null)
                IDL3();
        }
    }
    
    public void TipoDeDato(){
        TipoDeDato1();
        TipoDeDato2();
    }
    
    public void TipoDeDato1(){
        if(TokenActual.evaluarToken(Tokens.DatoBin, null) || TokenActual.evaluarToken(Tokens.DatoBit, null) || TokenActual.evaluarToken(Tokens.DatoDecimal, null)
                 || TokenActual.evaluarToken(Tokens.DatoEntero, null) || TokenActual.evaluarToken(Tokens.DatoFechaHora, null) || TokenActual.evaluarToken(Tokens.DatoTexto, null)){
            TipoDeDato3();
        }
        else if(TokenActual.evaluarToken(Tokens.Operador, "[")){
            ReadNextTokenElement(Tokens.Operador, "[");
            if(Error == null)
                TipoDeDato3();
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, "]");
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement(null, Tokens.DatoBin));
            elementos.add(new TokenElement(null, Tokens.DatoBit));
            elementos.add(new TokenElement(null, Tokens.DatoDecimal));
            elementos.add(new TokenElement(null, Tokens.DatoEntero));
            elementos.add(new TokenElement(null, Tokens.DatoFechaHora));
            elementos.add(new TokenElement(null, Tokens.DatoTexto));
            elementos.add(new TokenElement("[", Tokens.Operador));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void TipoDeDato3(){
        if(TokenActual.evaluarToken(Tokens.DatoBin, null)){
            ReadNextTokenElement(Tokens.DatoBin, null);
        }
        else if(TokenActual.evaluarToken(Tokens.DatoBit, null)){
            ReadNextTokenElement(Tokens.DatoBit, null);
        }
        else if(TokenActual.evaluarToken(Tokens.DatoDecimal, null)){
            ReadNextTokenElement(Tokens.DatoDecimal, null);
        }
        else if(TokenActual.evaluarToken(Tokens.DatoEntero, null)){
            ReadNextTokenElement(Tokens.DatoEntero, null);
        }
        else if(TokenActual.evaluarToken(Tokens.DatoFechaHora, null)){
            ReadNextTokenElement(Tokens.DatoFechaHora, null);
        }
        else if(TokenActual.evaluarToken(Tokens.DatoTexto, null)){
            ReadNextTokenElement(Tokens.DatoTexto, null);
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement(null, Tokens.DatoBin));
            elementos.add(new TokenElement(null, Tokens.DatoBit));
            elementos.add(new TokenElement(null, Tokens.DatoDecimal));
            elementos.add(new TokenElement(null, Tokens.DatoEntero));
            elementos.add(new TokenElement(null, Tokens.DatoFechaHora));
            elementos.add(new TokenElement(null, Tokens.DatoTexto));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void TipoDeDato2(){
        if(TokenActual.evaluarToken(Tokens.Operador, "(")){
            ReadNextTokenElement(Tokens.Operador, "(");
            if(Error == null)
                ReadNextTokenElement(Tokens.Integer, null);
            if(Error == null)
                TipoDeDato4();
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, ")");
        }
    }
    
    public void TipoDeDato4(){
        if(TokenActual.evaluarToken(Tokens.Operador, ",")){
            ReadNextTokenElement(Tokens.Operador, ",");
            if(Error == null)
                ReadNextTokenElement(Tokens.Integer, null);
        }
    }
    
    public void IfExists(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "IF")){
            ReadNextTokenElement(Tokens.Reservada, "IF");
            if(Error == null)
                ReadNextTokenElement(Tokens.Reservada, "EXISTS");
        }
    }
    
    public void Drop(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "DROP")){
            ReadNextTokenElement(Tokens.Reservada, "DROP");
            if(Error == null)
                DropOptions();
        }
    }
    
    public void DropOptions(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "TABLE")){
            DropTable();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "USER")){
            DropUser();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "VIEW")){
            DropView();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "DATABASE")){
            DropDataBase();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "INDEX")){
            DropIndex();
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement("TABLE", Tokens.Reservada));
            elementos.add(new TokenElement("USER", Tokens.Reservada));
            elementos.add(new TokenElement("VIEW", Tokens.Reservada));
            elementos.add(new TokenElement("DATABASE", Tokens.Reservada));
            elementos.add(new TokenElement("INDEX", Tokens.Reservada));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void DropTable(){
        ReadNextTokenElement(Tokens.Reservada, "TABLE");
        if(Error == null)
            IfExists();
        if(Error == null)
            IDL3();
        if(Error == null)
            DropTable1();
    }
    
    public void DropTable1(){
        if(TokenActual.evaluarToken(Tokens.Operador, ",")){
            ReadNextTokenElement(Tokens.Operador, ",");
            if(Error == null)
                IDL3();
            if(Error == null)
                DropTable1();
        }
    }
    
    public void DropUser(){
        ReadNextTokenElement(Tokens.Reservada, "USER");
        if(Error == null)
            IfExists();
        if(Error == null)
            ID();
    }
    
    public void DropView(){
        ReadNextTokenElement(Tokens.Reservada, "VIEW");
        if(Error == null)
            IfExists();
        if(Error == null)
            IDL1();
        if(Error == null)
            DropView1();
    }
    
    public void DropView1(){
        if(TokenActual.evaluarToken(Tokens.Operador, ",")){
            ReadNextTokenElement(Tokens.Operador, ",");
            if(Error == null)
                IDL1();
            if(Error == null)
                DropView1();
        }
    }
    
    public void DropDataBase(){
        ReadNextTokenElement(Tokens.Reservada, "DATABASE");
        if(Error == null)
            IfExists();
        if(Error == null)
            ID();
        if(Error == null)
            DropDataBase1();
    }
    
    public void DropDataBase1(){
        if(TokenActual.evaluarToken(Tokens.Operador, ",")){
            ReadNextTokenElement(Tokens.Operador, ",");
            if(Error == null)
                ID();
            if(Error == null)
                DropDataBase1();
        }
    }
    
    public void DropIndex(){
        ReadNextTokenElement(Tokens.Reservada, "INDEX");
        if(Error == null)
            IfExists();
        if(Error == null)
            DropIndex1();
        if(Error == null)
            DropIndex2();
    }
    
    public void DropIndex1(){
        ID();
        if(Error == null)
            ReadNextTokenElement(Tokens.Reservada, "ON");
        if(Error == null)
            IDL3();
    }
    
    public void DropIndex2(){
        if(TokenActual.evaluarToken(Tokens.Operador, ",")){
            ReadNextTokenElement(Tokens.Operador, ",");
            if(Error == null)
                DropIndex1();
            if(Error == null)
                DropIndex2();
        }
    }
    
    public void Truncate(){
        ReadNextTokenElement(Tokens.Reservada, "TRUNCATE");
        if(Error == null)
            ReadNextTokenElement(Tokens.Reservada, "TABLE");
        if(Error == null)
            IDL3();
    }
    
    public void AsElement(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "AS")){
            ReadNextTokenElement(Tokens.Reservada, "AS");
            AsElement1();
        }
        else if(FirstID() || TokenActual.evaluarToken(Tokens.Varchar, null)){
            AsElement1();
        }
    }
    
    public void AsElement1(){
        if(FirstID()){
            ID();
        }
        else if(TokenActual.evaluarToken(Tokens.Varchar, null)){
            ReadNextTokenElement(Tokens.Varchar, null);
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement(null, Tokens.Identificador));
            elementos.add(new TokenElement("[", Tokens.Operador));
            elementos.add(new TokenElement(null, Tokens.Varchar));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void Operacion(){
        Operacion2();
        if(Error == null)
            Operacion1();
    }
    
    public void Operacion1(){
        if(TokenActual.evaluarToken(Tokens.Operador, "+")){
            ReadNextTokenElement(Tokens.Operador, "+");
            if(Error == null)
                Operacion2();
            if(Error == null)
                Operacion1();
        }
        else if(TokenActual.evaluarToken(Tokens.Operador, "-")){
            ReadNextTokenElement(Tokens.Operador, "-");
            if(Error == null)
                Operacion2();
            if(Error == null)
                Operacion1();
        }
    }
    
    public void Operacion2(){
        Operacion4();
        if(Error == null)
            Operacion3();
    }
    
    public void Operacion3(){
        if(TokenActual.evaluarToken(Tokens.Operador, "/")){
            ReadNextTokenElement(Tokens.Operador, "/");
            if(Error == null)
                Operacion4();
            if(Error == null)
                Operacion3();
        }
        else if(TokenActual.evaluarToken(Tokens.Operador, "*")){
            ReadNextTokenElement(Tokens.Operador, "*");
            if(Error == null)
                Operacion4();
            if(Error == null)
                Operacion3();
        }
    }
    
    public boolean FirstID(){
        return TokenActual.evaluarToken(Tokens.Identificador, null) || TokenActual.evaluarToken(Tokens.Operador, "[");
    }
    
    public boolean FirstOperacion(){
        return TokenActual.evaluarToken(Tokens.Integer, null) || TokenActual.evaluarToken(Tokens.Float, null)
                || TokenActual.evaluarToken(Tokens.Bit, null) || TokenActual.evaluarToken(Tokens.Varchar, null)
                || TokenActual.evaluarToken(Tokens.Reservada, "NULL") || TokenActual.evaluarToken(Tokens.Reservada, "COUNT")
                || TokenActual.evaluarToken(Tokens.Reservada, "SUM") || TokenActual.evaluarToken(Tokens.Reservada, "AVG")
                || TokenActual.evaluarToken(Tokens.Reservada, "MIN") || TokenActual.evaluarToken(Tokens.Reservada, "MAX")
                || TokenActual.evaluarToken(Tokens.Identificador, null) || TokenActual.evaluarToken(Tokens.Operador, "[")
                || TokenActual.evaluarToken(Tokens.Operador, "(");
    }
    
    public void Operacion4(){
        if(TokenActual.evaluarToken(Tokens.Operador, "(")){
            ReadNextTokenElement(Tokens.Operador, "(");
            if(Error == null)
                Operacion();
            if(Error == null)
                Operacion();
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, ")");
        }
        else if(FirstID() || FirstOperacion()){
            Operacion5();
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement(null, Tokens.Bit));
            elementos.add(new TokenElement(null, Tokens.Identificador));
            elementos.add(new TokenElement("[", Tokens.Operador));
            elementos.add(new TokenElement(null, Tokens.Integer));
            elementos.add(new TokenElement(null, Tokens.Float));
            elementos.add(new TokenElement(null, Tokens.Varchar));
            elementos.add(new TokenElement("NULL", Tokens.Reservada));
            elementos.add(new TokenElement("AVG", Tokens.Reservada));
            elementos.add(new TokenElement("SUM", Tokens.Reservada));
            elementos.add(new TokenElement("COUNT", Tokens.Reservada));
            elementos.add(new TokenElement("MAX", Tokens.Reservada));
            elementos.add(new TokenElement("MIN", Tokens.Reservada));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void Operacion5(){
        if(FirstID()){
            IDL5();
        }
        else if(TokenActual.evaluarToken(Tokens.Integer, null)){
            ReadNextTokenElement(Tokens.Integer, null);
        }
        else if(TokenActual.evaluarToken(Tokens.Varchar, null)){
            ReadNextTokenElement(Tokens.Varchar, null);
        }
        else if(TokenActual.evaluarToken(Tokens.Float, null)){
            ReadNextTokenElement(Tokens.Float, null);
        }
        else if(TokenActual.evaluarToken(Tokens.Bit, null)){
            ReadNextTokenElement(Tokens.Bit, null);
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "NULL")){
            ReadNextTokenElement(Tokens.Reservada, "NULL");
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "SUM")){
            ReadNextTokenElement(Tokens.Reservada, "SUM");
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, "(");
            if(Error == null)
                Operacion6();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "AVG")){
            ReadNextTokenElement(Tokens.Reservada, "AVG");
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, "(");
            if(Error == null)
                Operacion6();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "COUNT")){
            ReadNextTokenElement(Tokens.Reservada, "COUNT");
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, "(");
            if(Error == null)
                Operacion6();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "MAX")){
            ReadNextTokenElement(Tokens.Reservada, "MAX");
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, "(");
            if(Error == null)
                Operacion6();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "MIN")){
            ReadNextTokenElement(Tokens.Reservada, "MIN");
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, "(");
            if(Error == null)
                Operacion6();
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement(null, Tokens.Bit));
            elementos.add(new TokenElement(null, Tokens.Identificador));
            elementos.add(new TokenElement("[", Tokens.Operador));
            elementos.add(new TokenElement(null, Tokens.Integer));
            elementos.add(new TokenElement(null, Tokens.Float));
            elementos.add(new TokenElement(null, Tokens.Varchar));
            elementos.add(new TokenElement("NULL", Tokens.Reservada));
            elementos.add(new TokenElement("AVG", Tokens.Reservada));
            elementos.add(new TokenElement("SUM", Tokens.Reservada));
            elementos.add(new TokenElement("COUNT", Tokens.Reservada));
            elementos.add(new TokenElement("MAX", Tokens.Reservada));
            elementos.add(new TokenElement("MIN", Tokens.Reservada));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void Operacion6(){
        if(FirstID()){
            IDL5();
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, ")");
        }
        else if(TokenActual.evaluarToken(Tokens.Integer, null)){
            ReadNextTokenElement(Tokens.Integer, null);
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, ")");
        }
        else if(TokenActual.evaluarToken(Tokens.Operador, "*")){
            ReadNextTokenElement(Tokens.Operador, "*");
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, ")");
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement(null, Tokens.Identificador));
            elementos.add(new TokenElement("[", Tokens.Operador));
            elementos.add(new TokenElement(null, Tokens.Integer));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void Operaciones(){
        if(TokenActual.evaluarToken(Tokens.Operador, ",")){
            ReadNextTokenElement(Tokens.Operador, ",");
            if(Error == null)
                Operacion();
            if(Error == null)
                Operaciones();
        }
    }
    
    public void Not(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "NOT")){
            ReadNextTokenElement(Tokens.Reservada, "NOT");
        }
    }
    
    public void Top(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "TOP")){
            ReadNextTokenElement(Tokens.Reservada, "TOP");
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, "(");
            if(Error == null)
                ReadNextTokenElement(Tokens.Integer, null);
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, ")");
            if(Error == null)
                Top1();
        }
    }
    
    public void Top1(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "PERCENT")){
            ReadNextTokenElement(Tokens.Reservada, "PERCENT");
        }
    }
    
    public void Condicion(){
        Not();
        if(FirstID() || FirstOperacion() || TokenActual.evaluarToken(Tokens.Operador, "(")){
            Condicion2();
            if(Error == null)
                Condicion1();
        }
        else if(TokenActual.evaluarToken(Tokens.Operador, "(")){
            ReadNextTokenElement(Tokens.Operador, "(");
            if(Error == null)
                Condicion();
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, ")");
            if(Error == null)
                Condicion1();
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement("(", Tokens.Operador));
            elementos.add(new TokenElement(null, Tokens.Bit));
            elementos.add(new TokenElement(null, Tokens.Identificador));
            elementos.add(new TokenElement("[", Tokens.Operador));
            elementos.add(new TokenElement(null, Tokens.Integer));
            elementos.add(new TokenElement(null, Tokens.Float));
            elementos.add(new TokenElement(null, Tokens.Varchar));
            elementos.add(new TokenElement("NULL", Tokens.Reservada));
            elementos.add(new TokenElement("AVG", Tokens.Reservada));
            elementos.add(new TokenElement("SUM", Tokens.Reservada));
            elementos.add(new TokenElement("COUNT", Tokens.Reservada));
            elementos.add(new TokenElement("MAX", Tokens.Reservada));
            elementos.add(new TokenElement("MIN", Tokens.Reservada));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void Condicion1(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "AND")){
            ReadNextTokenElement(Tokens.Reservada, "AND");
            if(Error == null)
                Condicion();
            if(Error == null)
                Condicion1();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "OR")){
            ReadNextTokenElement(Tokens.Reservada, "OR");
            if(Error == null)
                Condicion();
            if(Error == null)
                Condicion1();
        }
    }
    
    public void Condicion2(){
        Operacion();
        if(Error == null)
            Condicion3();
    }
    
    public void Condicion3(){
        if(TokenActual.evaluarToken(Tokens.OperadorBooleano, null)){
            ReadNextTokenElement(Tokens.OperadorBooleano, null);
            if(Error == null)
                Operacion();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "IS")){
            ReadNextTokenElement(Tokens.Reservada, "IS");
            if(Error == null)
                Not();
            if(Error == null)
                ReadNextTokenElement(Tokens.Reservada, "NULL");
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "IN") || TokenActual.evaluarToken(Tokens.Reservada, "BETWEEN") || TokenActual.evaluarToken(Tokens.Reservada, "LIKE")){
            if(Error == null)
                Not();
            if(Error == null)
                Condicion4();
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement(null, Tokens.OperadorBooleano));
            elementos.add(new TokenElement("IS", Tokens.Reservada));
            elementos.add(new TokenElement("IN", Tokens.Reservada));
            elementos.add(new TokenElement("BETWEEN", Tokens.Reservada));
            elementos.add(new TokenElement("LIKE", Tokens.Reservada));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void Condicion4(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "IN")){
            ReadNextTokenElement(Tokens.Reservada, "IN");
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, "(");
            if(Error == null)
                Operacion();
            if(Error == null)
                Operaciones();
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, ")");
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "BETWEEN")){
            ReadNextTokenElement(Tokens.Reservada, "BETWEEN");
            if(Error == null)
                Operacion();
            if(Error == null)
                ReadNextTokenElement(Tokens.Reservada, "AND");
            if(Error == null)
                Operacion();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "LIKE")){
            ReadNextTokenElement(Tokens.Reservada, "LIKE");
            if(Error == null)
                Operacion();
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement("IN", Tokens.Reservada));
            elementos.add(new TokenElement("BETWEEN", Tokens.Reservada));
            elementos.add(new TokenElement("LIKE", Tokens.Reservada));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void Where(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "WHERE")){
            ReadNextTokenElement(Tokens.Reservada, "WHERE");
            if(Error == null)
                Condicion();
        }
    }
    
    public void Select(){
        ReadNextTokenElement(Tokens.Reservada, "SELECT");
        if(Error == null)
            Select1();
        if(Error == null)
            Top();
        if(Error == null)
            SelectColumnas();
        if(Error == null)
            SelectFrom();
        if(Error == null)
            Where();
        if(Error == null)
            GroupBy();
        if(Error == null)
            Having();
        if(Error == null)
            OrderBy();
    }
    
    public void Select1(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "ALL")){
             ReadNextTokenElement(Tokens.Reservada, "ALL");
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "DISTINCT")){
             ReadNextTokenElement(Tokens.Reservada, "DISTINCT");
        }
    }
    
    public void Having(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "HAVING")){
             ReadNextTokenElement(Tokens.Reservada, "HAVING");
             if(Error == null)
                 Condicion();
        }
    }
    
    public void OrderBy(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "ORDER")){
             ReadNextTokenElement(Tokens.Reservada, "ORDER");
             if(Error == null)
                 ReadNextTokenElement(Tokens.Reservada, "BY");
             if(Error == null)
                 Operacion();
             if(Error == null)
                 OrderBy1();
             if(Error == null)
                 OrderBy2();
             if(Error == null)
                 OrderBy3();
        }
    }
    
    public void OrderBy1(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "COLLATE")){
             ReadNextTokenElement(Tokens.Reservada, "COLLATE");
             if(Error == null)
                 ID();
        }
    }
    
    public void OrderBy2(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "ASC")){
             ReadNextTokenElement(Tokens.Reservada, "ASC");
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "DESC")){
             ReadNextTokenElement(Tokens.Reservada, "DESC");
        }
    }
    
    public void OrderBy3(){
        if(FirstOperacion()){
            Operacion();
            if(Error == null)
                OrderBy1();
            if(Error == null)
                OrderBy2();
        }
    }
    
    public void GroupBy(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "GROUP")){
             ReadNextTokenElement(Tokens.Reservada, "GROUP");
             if(Error == null)
                 ReadNextTokenElement(Tokens.Reservada, "BY");
             if(Error == null)
                 Operacion();
             if(Error == null)
                 GroupBy1();
        }
    }
    
    public void GroupBy1(){
        if(TokenActual.evaluarToken(Tokens.Operador, ",")){
             ReadNextTokenElement(Tokens.Operador, ",");
             if(Error == null)
                 Operacion();
             if(Error == null)
                 GroupBy1();
        }
    }
    
    public void SelectFrom(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "FROM")){
            ReadNextTokenElement(Tokens.Reservada, "FROM");
            if(Error == null)
                IDL3();
            if(Error == null)
                AsElement();
            if(Error == null)
                SelectFromJoin();
            if(Error == null)
                SelectFrom1();
        }
    }
    
    public void SelectFrom1(){
        if(TokenActual.evaluarToken(Tokens.Operador, ",")){
            ReadNextTokenElement(Tokens.Operador, ",");
            if(Error == null)    
                IDL3();
            if(Error == null)
                AsElement();
            if(Error == null)
                SelectFromJoin();
        }
    }
    
    public void SelectFromJoin(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "INNER") || TokenActual.evaluarToken(Tokens.Reservada, "RIGHT")
                || TokenActual.evaluarToken(Tokens.Reservada, "LEFT") || TokenActual.evaluarToken(Tokens.Reservada, "FULL")
                || TokenActual.evaluarToken(Tokens.Reservada, "JOIN")){
            JoinType();
            if(Error == null)
                ReadNextTokenElement(Tokens.Reservada, "JOIN");
            if(Error == null)
                IDL3();
            if(Error == null)
                AsElement();
            if(Error == null)
                ReadNextTokenElement(Tokens.Reservada, "ON");
            if(Error == null)
                Condicion();
            if(Error == null)
                SelectFromJoin();
        }
    }
    
    public void JoinType(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "INNER")){
            ReadNextTokenElement(Tokens.Reservada, "INNER");
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "RIGHT")){
            ReadNextTokenElement(Tokens.Reservada, "RIGHT");
            if(Error == null)
                JoinOuter();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "LEFT")){
            ReadNextTokenElement(Tokens.Reservada, "LEFT");
            if(Error == null)
                JoinOuter();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "FULL")){
            ReadNextTokenElement(Tokens.Reservada, "FULL");
            if(Error == null)
                JoinOuter();
        }
    }
    
    public void JoinOuter(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "OUTER")){
            ReadNextTokenElement(Tokens.Reservada, "OUTER");
        }
    }
    
    public void SelectColumnas(){
        if(FirstOperacion()){
            Operacion();
            if(Error == null)
                AsElement();
            if(Error == null)
                SelectColumnas1();
        }
        else if(TokenActual.evaluarToken(Tokens.Operador, "*")){
            ReadNextTokenElement(Tokens.Operador, "*");
            if(Error == null)
                SelectColumnas1();
        }
    }
    
    public void SelectColumnas1(){
        if(TokenActual.evaluarToken(Tokens.Operador, ",")){
            ReadNextTokenElement(Tokens.Operador, ",");
            if(Error == null)
                Operacion();
            if(Error == null)
                AsElement();
            if(Error == null)
                SelectColumnas1();
        }
    }
    
    public void ListaColumnas(){
        if(TokenActual.evaluarToken(Tokens.Operador, "(")){
            ReadNextTokenElement(Tokens.Operador, "(");
            if(Error == null)
                ListaColumnas1();
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, ")");
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement("(", Tokens.Operador));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void ListaColumnas1(){
        ID();
        ListaColumnas2();
    }
    
    public void ListaColumnas2(){
        if(TokenActual.evaluarToken(Tokens.Operador, ",")){
            ReadNextTokenElement(Tokens.Operador, ",");
            if(Error == null)
                ID();
            if(Error == null)
                ListaColumnas2();
        }
    }
    
    public void Insert(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "INSERT")){
            ReadNextTokenElement(Tokens.Reservada, "INSERT");
            if(Error == null)
                Top();
            if(Error == null)
                InsertInto();
            if(Error == null)
                IDL3();
            if(Error == null)
                InsertListaColumna();
            if(Error == null)
                InsertValores();
        }
    }
    
    public void InsertInto(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "INTO")){
            ReadNextTokenElement(Tokens.Reservada, "INTO");
        }
    }
    
    public void InsertListaColumna(){
        if(TokenActual.evaluarToken(Tokens.Operador, "(")){
            ListaColumnas();
        }
    }
    
    public void InsertTipo(){
        InsertTipo1();
        if(Error == null)
            InsertTipo2();
    }
    
    public void InsertTipo1(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "DEFAULT")){
            ReadNextTokenElement(Tokens.Reservada, "DEFAULT");
        }
        else if(TokenActual.evaluarToken(Tokens.Integer, null)){
            ReadNextTokenElement(Tokens.Integer, null);
        }
        else if(TokenActual.evaluarToken(Tokens.Float, null)){
            ReadNextTokenElement(Tokens.Float, null);
        }
        else if(TokenActual.evaluarToken(Tokens.Varchar, null)){
            ReadNextTokenElement(Tokens.Varchar, null);
        }
        else if(TokenActual.evaluarToken(Tokens.Bit, null)){
            ReadNextTokenElement(Tokens.Bit, null);
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement("DEFAULT", Tokens.Reservada));
            elementos.add(new TokenElement(null, Tokens.Bit));
            elementos.add(new TokenElement(null, Tokens.Integer));
            elementos.add(new TokenElement(null, Tokens.Float));
            elementos.add(new TokenElement(null, Tokens.Varchar));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void InsertTipo2(){
        if(TokenActual.evaluarToken(Tokens.Operador, ",")){
            ReadNextTokenElement(Tokens.Operador, ",");
            if(Error == null)
                InsertTipo1();
            if(Error == null)
                InsertTipo2();
        }
    }
    
    public void InsertValores(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "VALUES")){
            ReadNextTokenElement(Tokens.Reservada, "VALUES");
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, "(");
            if(Error == null)
                InsertTipo();
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, ")");
            if(Error == null)
                InsertValores1();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "DEFAULT")){
            ReadNextTokenElement(Tokens.Reservada, "DEFAULT");
            if(Error == null)
                ReadNextTokenElement(Tokens.Reservada, "VALUES");
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement("VALUES", Tokens.Reservada));
            elementos.add(new TokenElement("DEFAULT", Tokens.Reservada));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void InsertValores1(){
        if(TokenActual.evaluarToken(Tokens.Operador, ",")){
            ReadNextTokenElement(Tokens.Operador, ",");
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, "(");
            if(Error == null)
                InsertTipo();
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, ")");
            if(Error == null)
                InsertValores1();
        }
    }
    
    public void Delete(){
        ReadNextTokenElement(Tokens.Reservada, "DELETE");
        if(Error == null)
            Top();
        if(Error == null)
            DeleteFrom();
        if(Error == null)
            Delete1();
    }
    
    public void DeleteFrom(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "FROM")){
            ReadNextTokenElement(Tokens.Reservada, "FROM");
        }
    }
    
    public void Delete1(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "OPENQUERY")){
            ReadNextTokenElement(Tokens.Reservada, "OPENQUERY");
            if(Error == null)
                DeleteServer();
        }
        else if(FirstID()){
            IDL3();
            if(Error == null)
                Delete2();
            if(Error == null)
                Where();
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement("OPENQUERY", Tokens.Reservada));
            elementos.add(new TokenElement(null, Tokens.Identificador));
            elementos.add(new TokenElement("[", Tokens.Operador));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void Delete2(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "FROM")){
            ReadNextTokenElement(Tokens.Reservada, "FROM");
            if(Error == null)
                IDL3();
            if(Error == null)
                Delete3();
        }
    }
    
    public void Delete3(){
        if(TokenActual.evaluarToken(Tokens.Operador, ",")){
            ReadNextTokenElement(Tokens.Operador, ",");
            if(Error == null)
                IDL3();
            if(Error == null)
                Delete3();
        }
    }
    
    public void DeleteServer(){
        if(TokenActual.evaluarToken(Tokens.Operador, "(")){
            ReadNextTokenElement(Tokens.Operador, "(");
            if(Error == null)
                ID();
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, ",");
            if(Error == null)
                ReadNextTokenElement(Tokens.Varchar, null);
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, ")");
        }
    }
    
    public void Update(){
        ReadNextTokenElement(Tokens.Reservada, "UPDATE");
        if(Error == null)
            Top();
        if(Error == null)
            IDL3();
        if(Error == null)
            ReadNextTokenElement(Tokens.Reservada, "SET");
        if(Error == null)
            Update1();
        if(Error == null)
            Delete2();
        if(Error == null)
            Where();
    }
    
    public void Update1(){
        ID();
        if(Error == null)
            ReadNextTokenElement(Tokens.Operador, "=");
        if(Error == null)
            Update2();
        if(Error == null)
            Update3();
    }
    
    public void Update2(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "DEFAULT")){
            ReadNextTokenElement(Tokens.Reservada, "DEFAULT");
        }
        else if(FirstOperacion()){
            Operacion();
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement("DEFAULT", Tokens.Reservada));
            elementos.add(new TokenElement("(", Tokens.Operador));
            elementos.add(new TokenElement(null, Tokens.Bit));
            elementos.add(new TokenElement(null, Tokens.Identificador));
            elementos.add(new TokenElement("[", Tokens.Operador));
            elementos.add(new TokenElement(null, Tokens.Integer));
            elementos.add(new TokenElement(null, Tokens.Float));
            elementos.add(new TokenElement(null, Tokens.Varchar));
            elementos.add(new TokenElement("NULL", Tokens.Reservada));
            elementos.add(new TokenElement("AVG", Tokens.Reservada));
            elementos.add(new TokenElement("SUM", Tokens.Reservada));
            elementos.add(new TokenElement("COUNT", Tokens.Reservada));
            elementos.add(new TokenElement("MAX", Tokens.Reservada));
            elementos.add(new TokenElement("MIN", Tokens.Reservada));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void Update3(){
        if(TokenActual.evaluarToken(Tokens.Operador, ",")){
            ReadNextTokenElement(Tokens.Operador, ",");
            if(Error == null)
                Update1();
            if(Error == null)
                Update3();
        }
    }
    
    public void Create(){
        ReadNextTokenElement(Tokens.Reservada, "CREATE");
        if(Error == null)
            Create1();
    }
    
    public void Create1(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "TABLE")){
            CreateTable();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "DATABASE")){
            CreateDataBase();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "INDEX") || TokenActual.evaluarToken(Tokens.Reservada, "UNIQUE") 
                || TokenActual.evaluarToken(Tokens.Reservada, "CLUSTERED") || TokenActual.evaluarToken(Tokens.Reservada, "NONCLUSTERED")){
            CreateIndex();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "USER")){
            CreateUser();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "VIEW")){
            CreateView();
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement("TABLE", Tokens.Reservada));
            elementos.add(new TokenElement("DATABASE", Tokens.Reservada));
            elementos.add(new TokenElement("INDEX", Tokens.Reservada));
            elementos.add(new TokenElement("UNIQUE", Tokens.Reservada));
            elementos.add(new TokenElement("CLUSTERED", Tokens.Reservada));
            elementos.add(new TokenElement("NONCLUSTERED", Tokens.Reservada));
            elementos.add(new TokenElement("USER", Tokens.Reservada));
            elementos.add(new TokenElement("VIEW", Tokens.Reservada));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void CreateTable(){
        ReadNextTokenElement(Tokens.Reservada, "TABLE");
        if(Error == null)
            IDL3();
        if(Error == null)
            ReadNextTokenElement(Tokens.Operador, "(");
        if(Error == null)
            TableElement2();
        if(Error == null)
            TableElement3();
        if(Error == null)
            ReadNextTokenElement(Tokens.Operador, ")");
    }
    
    public void TableElement1(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "NOT")){
            ReadNextTokenElement(Tokens.Reservada, "NOT");
            if(Error == null)
                ReadNextTokenElement(Tokens.Reservada, "FOR");
            if(Error == null)
                ReadNextTokenElement(Tokens.Reservada, "REPLICATION");
        }
    }
    
    public void TableElement2(){
        if(FirstID()){
            DefinicionColumna();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "PRIMARY") || TokenActual.evaluarToken(Tokens.Reservada, "UNIQUE")
                || TokenActual.evaluarToken(Tokens.Reservada, "FOREIGN") || TokenActual.evaluarToken(Tokens.Reservada, "CHECK")){
            ConstraintTabla();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "INDEX")){
            IndexTabla();
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement(null, Tokens.Identificador));
            elementos.add(new TokenElement("[", Tokens.Operador));
            elementos.add(new TokenElement("PRIMARY", Tokens.Reservada));
            elementos.add(new TokenElement("UNIQUE", Tokens.Reservada));
            elementos.add(new TokenElement("FOREIGN", Tokens.Reservada));
            elementos.add(new TokenElement("CHECK", Tokens.Reservada));
            elementos.add(new TokenElement("INDEX", Tokens.Reservada));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void TableElement3(){
        if(TokenActual.evaluarToken(Tokens.Operador, ",")){
            ReadNextTokenElement(Tokens.Operador, ",");
            if(Error == null)
                TableElement2();
            if(Error == null)
                TableElement3();
        }
    }
    
    public void DefinicionColumna(){
        ID();
        if(Error == null)
            TipoDeDato();
        if(Error == null)
            DefinicionColumna1();
        if(Error == null)
            DefinicionColumna2();
        if(Error == null)
            DefinicionColumna3();
        if(Error == null)
            TableElement1();
        if(Error == null)
            DefinicionColumna4();
        if(Error == null)
            DefinicionColumna5();
        if(Error == null)
            ConstraintColumna();
    }
    
    public void DefinicionColumna1(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "COLLATE")){
            ReadNextTokenElement(Tokens.Reservada, "COLLATE");
            if(Error == null)
                ID();
        }
    }
    
    public void DefinicionColumna2(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "CONSTRAINT")){
            ReadNextTokenElement(Tokens.Reservada, "CONSTRAINT");
            if(Error == null)
                ID();
            if(Error == null)
                DefinicionColumna6();
        }
    }
    
    public void DefinicionColumna3(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "IDENTITY")){
            ReadNextTokenElement(Tokens.Reservada, "IDENTITY");
            if(Error == null)
                DefinicionColumna7();
        }
    }
    
    public void DefinicionColumna4(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "NULL")){
            ReadNextTokenElement(Tokens.Reservada, "NULL");
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "NOT")){
            ReadNextTokenElement(Tokens.Reservada, "NOT");
            if(Error == null)
                ReadNextTokenElement(Tokens.Reservada, "NULL");
        }
    }
    
    public void DefinicionColumna5(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "ROWGUIDCOL")){
            ReadNextTokenElement(Tokens.Reservada, "ROWGUIDCOL");
        }
    }
    
    public void DefinicionColumna6(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "DEFAULT")){
            ReadNextTokenElement(Tokens.Reservada, "DEFAULT");
            if(Error == null)
                DefinicionColumna8();
        }
    }
    
    public void DefinicionColumna7(){
         if(TokenActual.evaluarToken(Tokens.Operador, "(")){
            ReadNextTokenElement(Tokens.Operador, "(");
            if(Error == null)
                ReadNextTokenElement(Tokens.Integer, null);
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, ",");
            if(Error == null)
                ReadNextTokenElement(Tokens.Integer, null);
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, ")");
        }
    }
    
    public void DefinicionColumna8(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "NULL")){
            ReadNextTokenElement(Tokens.Reservada, "NULL");
        }
        else if(TokenActual.evaluarToken(Tokens.Integer, null)){
            ReadNextTokenElement(Tokens.Integer, null);
        }
        else if(TokenActual.evaluarToken(Tokens.Float, null)){
            ReadNextTokenElement(Tokens.Float, null);
        }
        else if(TokenActual.evaluarToken(Tokens.Varchar, null)){
            ReadNextTokenElement(Tokens.Varchar, null);
        }
        else if(TokenActual.evaluarToken(Tokens.Bit, null)){
            ReadNextTokenElement(Tokens.Bit, null);
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement("NULL", Tokens.Reservada));
            elementos.add(new TokenElement(null, Tokens.Bit));
            elementos.add(new TokenElement(null, Tokens.Integer));
            elementos.add(new TokenElement(null, Tokens.Float));
            elementos.add(new TokenElement(null, Tokens.Varchar));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void ConstraintTabla(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "CONSTRAINT") || TokenActual.evaluarToken(Tokens.Reservada, "PRIMARY") 
                || TokenActual.evaluarToken(Tokens.Reservada, "UNIQUE") || TokenActual.evaluarToken(Tokens.Reservada, "FOREIGN") 
                || TokenActual.evaluarToken(Tokens.Reservada, "CHECK")){
            ConstraintColumna1();
            if(Error == null)
                ConstraintTabla1();
        }
    }
    
    public void ConstraintTabla1(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "PRIMARY")){
            ReadNextTokenElement(Tokens.Reservada, "PRIMARY");
            if(Error == null)
                ReadNextTokenElement(Tokens.Reservada, "KEY");
            if(Error == null)
                ConstraintColumna3();
            if(Error == null)
                ConstraintTabla2();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "UNIQUE")){
            ReadNextTokenElement(Tokens.Reservada, "UNIQUE");
            if(Error == null)
                ConstraintColumna3();
            if(Error == null)
                ConstraintTabla2();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "FOREIGN")){
            ReadNextTokenElement(Tokens.Reservada, "FOREIGN");
            if(Error == null)
                ReadNextTokenElement(Tokens.Reservada, "KEY");
            if(Error == null)
                ConstraintTabla4();
            if(Error == null)
                ReadNextTokenElement(Tokens.Reservada, "REFERENCES");
            if(Error == null)
                IDL1();
            if(Error == null)
                ConstraintColumna5();
            if(Error == null)
                ConstraintColumna6();
            if(Error == null)
                ConstraintColumna7();
            if(Error == null)
                TableElement1();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "CHECK")){
            ReadNextTokenElement(Tokens.Reservada, "CHECK");
            if(Error == null)
                TableElement1();
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, "(");
            if(Error == null)
                Condicion();
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, ")");
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement("PRIMARY", Tokens.Reservada));
            elementos.add(new TokenElement("UNIQUE", Tokens.Reservada));
            elementos.add(new TokenElement("FOREIGN", Tokens.Reservada));
            elementos.add(new TokenElement("CHECK", Tokens.Reservada));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void ConstraintTabla2(){
        if(TokenActual.evaluarToken(Tokens.Operador, "(")){
            ReadNextTokenElement(Tokens.Operador, "(");
            if(Error == null)
                ID();
            /*if(Error == null)
                Order2();*/
            if(Error == null)
                ConstraintTabla3();
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, ")");
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement("(", Tokens.Operador));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void ConstraintTabla3(){
        if(TokenActual.evaluarToken(Tokens.Operador, ",")){
            ReadNextTokenElement(Tokens.Operador, ",");
            if(Error == null)
                ID();
            /*if(Error == null)
                Order2();*/
            if(Error == null)
                ConstraintTabla3();
        }
    }
    
    public void ConstraintTabla4(){
        if(TokenActual.evaluarToken(Tokens.Operador, "(")){
            ReadNextTokenElement(Tokens.Operador, "(");
            if(Error == null)
                ID();
            if(Error == null)
                ConstraintTabla5();
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, ")");
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement("(", Tokens.Operador));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void ConstraintTabla5(){
        if(TokenActual.evaluarToken(Tokens.Operador, ",")){
            ReadNextTokenElement(Tokens.Operador, ",");
            if(Error == null)
                ID();
            if(Error == null)
                ConstraintTabla5();
        }
    }
    
    public void ConstraintColumna(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "CONSTRAINT") || TokenActual.evaluarToken(Tokens.Reservada, "PRIMARY") 
                || TokenActual.evaluarToken(Tokens.Reservada, "UNIQUE") || TokenActual.evaluarToken(Tokens.Reservada, "FOREIGN") 
                || TokenActual.evaluarToken(Tokens.Reservada, "REFERENCES") || TokenActual.evaluarToken(Tokens.Reservada, "CHECK")){
            ConstraintColumna1();
            if(Error == null)
                ConstraintColumna2();
            if(Error == null)
                ConstraintColumna();
        }
    }
    
    public void ConstraintColumna1(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "CONSTRAINT")){
            ReadNextTokenElement(Tokens.Reservada, "CONSTRAINT");
            if(Error == null)
                ID();
        }
    }
    
    public void ConstraintColumna2(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "PRIMARY")){
            ReadNextTokenElement(Tokens.Reservada, "PRIMARY");
            if(Error == null)
                ReadNextTokenElement(Tokens.Reservada, "KEY");
            if(Error == null)
                ConstraintColumna3();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "UNIQUE")){
            ReadNextTokenElement(Tokens.Reservada, "UNIQUE");
            if(Error == null)
                ConstraintColumna3();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "FOREIGN") || TokenActual.evaluarToken(Tokens.Reservada, "REFERENCES")){
            ConstraintColumna4();
            if(Error == null)
                ReadNextTokenElement(Tokens.Reservada, "REFERENCES");
            if(Error == null)
                IDL1();
            if(Error == null)
                ConstraintColumna5();
            if(Error == null)
                ConstraintColumna6();
            if(Error == null)
                ConstraintColumna7();
            if(Error == null)
                TableElement1();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "CHECK")){
            ReadNextTokenElement(Tokens.Reservada, "CHECK");
            if(Error == null)
                TableElement1();
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, "(");
            if(Error == null)
                Condicion();
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, ")");
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement("CONSTRAINT", Tokens.Reservada));
            elementos.add(new TokenElement("PRIMARY", Tokens.Reservada));
            elementos.add(new TokenElement("UNIQUE", Tokens.Reservada));
            elementos.add(new TokenElement("FOREIGN", Tokens.Reservada));
            elementos.add(new TokenElement("CHECK", Tokens.Reservada));
            elementos.add(new TokenElement("REFERENCES", Tokens.Reservada));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void ConstraintColumna3(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "CLUSTERED")){
            ReadNextTokenElement(Tokens.Reservada, "CLUSTERED");
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "NONCLUSTERED")){
            ReadNextTokenElement(Tokens.Reservada, "NONCLUSTERED");
        }
    }
    
    public void ConstraintColumna4(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "FOREIGN")){
            ReadNextTokenElement(Tokens.Reservada, "FOREIGN");
            if(Error == null)
                ReadNextTokenElement(Tokens.Reservada, "KEY");
        }
    }
    
    public void ConstraintColumna5(){
        if(TokenActual.evaluarToken(Tokens.Operador, "(")){
            ReadNextTokenElement(Tokens.Operador, "(");
            if(Error == null)
                ID();
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, ")");
        }
    }
    
    public void ConstraintColumna6(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "ON")){
            ReadNextTokenElement(Tokens.Reservada, "ON");
            if(Error == null)
                ReadNextTokenElement(Tokens.Reservada, "DELETE");
            if(Error == null)
                ConstraintColumna9();
        }
    }
    
    public void ConstraintColumna7(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "ON")){
            ReadNextTokenElement(Tokens.Reservada, "ON");
            if(Error == null)
                ReadNextTokenElement(Tokens.Reservada, "UPDATE");
            if(Error == null)
                ConstraintColumna9();
        }
    }
    
    public void ConstraintColumna8(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "NULL")){
            ReadNextTokenElement(Tokens.Reservada, "NULL");
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "DEFAULT")){
            ReadNextTokenElement(Tokens.Reservada, "DEFAULT");
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement("NULL", Tokens.Reservada));
            elementos.add(new TokenElement("DEFAULT", Tokens.Reservada));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void ConstraintColumna9(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "CASCADE")){
            ReadNextTokenElement(Tokens.Reservada, "CASCADE");
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "SET")){
            ReadNextTokenElement(Tokens.Reservada, "SET");
            if(Error == null)
                ConstraintColumna8();
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement("CASCADE", Tokens.Reservada));
            elementos.add(new TokenElement("SET", Tokens.Reservada));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void IndexTabla(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "INDEX")){
            ReadNextTokenElement(Tokens.Reservada, "INDEX");
            if(Error == null)
                ID();
            if(Error == null)
                ConstraintColumna3();
            if(Error == null)
                ConstraintTabla2();
        }
    }
    
    public void CreateDataBase(){
        ReadNextTokenElement(Tokens.Reservada, "DATABASE");
        if(Error == null)
            ID();
        if(Error == null)
            CreateDataBase1();
    }
    
    public void CreateDataBase1(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "COLLATE")){
            ReadNextTokenElement(Tokens.Reservada, "COLLATE");
            if(Error == null)
                ID();
        }
    }
    
    public void CreateIndex(){
        CreateIndex1();
        if(Error == null)
            ConstraintColumna3();
        if(Error == null)
            ReadNextTokenElement(Tokens.Reservada, "INDEX");
        if(Error == null)
            ID();
        if(Error == null)
            ReadNextTokenElement(Tokens.Reservada, "ON");
        if(Error == null)
            IDL3();
        if(Error == null)
            IndexColumna();
        if(Error == null)
            IndexInclude();
        if(Error == null)
            Where();
    }
    
    public void CreateIndex1(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "UNIQUE")){
            ReadNextTokenElement(Tokens.Reservada, "UNIQUE");
        }
    }
    
    public void IndexInclude(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "INCLUDE")){
            ReadNextTokenElement(Tokens.Reservada, "INCLUDE");
            if(Error == null)
                ListaColumnas();
        }
    }
    
    public void IndexColumna(){
        if(TokenActual.evaluarToken(Tokens.Operador, "(")){
            ReadNextTokenElement(Tokens.Operador, "(");
            if(Error == null)
                IndexColumna1();
            if(Error == null)
                ReadNextTokenElement(Tokens.Operador, ")");
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement("(", Tokens.Operador));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void IndexColumna1(){
        ID();
        /*if(Error == null)
            Order2();*/
        if(Error == null)
            IndexColumna2();
    }
    
    public void IndexColumna2(){
        if(TokenActual.evaluarToken(Tokens.Operador, ",")){
            ReadNextTokenElement(Tokens.Operador, ",");
            if(Error == null)
                ID();
            /*if(Error == null)
                Order2();*/
            if(Error == null)
                IndexColumna2();
        }
    }
    
    public void CreateUser(){
        ReadNextTokenElement(Tokens.Reservada, "USER");
        if(Error == null)
            ID();
    }
    
    public void CreateView(){
        ReadNextTokenElement(Tokens.Reservada, "VIEW");
        if(Error == null)
            IDL1();
        if(Error == null)
            ReadNextTokenElement(Tokens.Reservada, "AS");
        if(Error == null)
            Select();
    }
    
    public void Alter(){
        ReadNextTokenElement(Tokens.Reservada, "ALTER");
        if(Error == null)
            Alter1();
    }
    
    public void Alter1(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "TABLE")){
            AlterTable();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "USER")){
            AlterUser();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "DATABASE")){
            AlterDataBase();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "VIEW")){
            AlterView();
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement("TABLE", Tokens.Reservada));
            elementos.add(new TokenElement("DATABASE", Tokens.Reservada));
            elementos.add(new TokenElement("USER", Tokens.Reservada));
            elementos.add(new TokenElement("VIEW", Tokens.Reservada));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void AlterDataBase(){
        ReadNextTokenElement(Tokens.Reservada, "DATABASE");
        if(Error == null)
            AlterDataBase1();
        if(Error == null)
            AlterDataBase2();
    }
    
    public void AlterDataBase1(){
        if(FirstID()){
            ID();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "CURRENT")){
            ReadNextTokenElement(Tokens.Reservada, "CURRENT");
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement(null, Tokens.Identificador));
            elementos.add(new TokenElement("[", Tokens.Operador));
            elementos.add(new TokenElement("CURRENT", Tokens.Reservada));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void AlterDataBase2(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "COLLATE")){
            ReadNextTokenElement(Tokens.Reservada, "COLLATE");
            if(Error == null)
                ID();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "SET")){
            ReadNextTokenElement(Tokens.Reservada, "SET");
            if(Error == null)
                ReadNextTokenElement(Tokens.Reservada, "ROLLBACK");
            if(Error == null)
                ReadNextTokenElement(Tokens.Reservada, "IMMEDIATE");
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement("COLLATE", Tokens.Reservada));
            elementos.add(new TokenElement("SET", Tokens.Reservada));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void AlterUser(){
        ReadNextTokenElement(Tokens.Reservada, "USER");
        if(Error == null)
            ID();
    }
    
    public void AlterView(){
        ReadNextTokenElement(Tokens.Reservada, "VIEW");
        if(Error == null)
            IDL1();
        if(Error == null)
            AlterView1();
        if(Error == null)
            ReadNextTokenElement(Tokens.Reservada, "AS");
        if(Error == null)
            Select();
    }
    
    public void AlterView1(){
        if(TokenActual.evaluarToken(Tokens.Operador, "(")){
             ListaColumnas();
        }
    }
    
    public void AlterTable(){
        ReadNextTokenElement(Tokens.Reservada, "TABLE");
        if(Error == null)
            IDL3();
        if(Error == null)
            AlterTable1();
    }
    
    public void AlterTable1(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "ALTER")){
            AlterColumna();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "ADD")){
            ReadNextTokenElement(Tokens.Reservada, "ADD");
            if(Error == null)
                TableElement2();
            if(Error == null)
                TableElement3();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "DROP")){
            AlterDrop();
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement("ALTER", Tokens.Reservada));
            elementos.add(new TokenElement("ADD", Tokens.Reservada));
            elementos.add(new TokenElement("DROP", Tokens.Reservada));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void AlterColumna(){
        ReadNextTokenElement(Tokens.Reservada, "ALTER");
        if(Error == null)
            ReadNextTokenElement(Tokens.Reservada, "COLUMN");
        if(Error == null)
            ID();
        if(Error == null)
            AlterColumna1();
    }
    
    public void AlterColumna1(){
        if(TokenActual.evaluarToken(Tokens.DatoBin, null) || TokenActual.evaluarToken(Tokens.DatoBit, null) 
                || TokenActual.evaluarToken(Tokens.DatoDecimal, null) || TokenActual.evaluarToken(Tokens.DatoEntero, null)
                || TokenActual.evaluarToken(Tokens.DatoFechaHora, null) || TokenActual.evaluarToken(Tokens.DatoTexto, null)
                || TokenActual.evaluarToken(Tokens.Operador, "[")){
            AlterColumna2();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "ADD") || TokenActual.evaluarToken(Tokens.Reservada, "DROP")){
            AlterColumna3();
            if(Error == null)
                AlterColumna4();
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement(null, Tokens.DatoBin));
            elementos.add(new TokenElement(null, Tokens.DatoBit));
            elementos.add(new TokenElement(null, Tokens.DatoDecimal));
            elementos.add(new TokenElement(null, Tokens.DatoEntero));
            elementos.add(new TokenElement(null, Tokens.DatoFechaHora));
            elementos.add(new TokenElement(null, Tokens.DatoTexto));
            elementos.add(new TokenElement("[", Tokens.Operador));
            elementos.add(new TokenElement("ADD", Tokens.Reservada));
            elementos.add(new TokenElement("DROP", Tokens.Reservada));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void AlterColumna2(){
        TipoDeDato();
        if(Error == null)
            DefinicionColumna1();
        if(Error == null)
            DefinicionColumna4();
    }
    
    public void AlterColumna3(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "ADD")){
            ReadNextTokenElement(Tokens.Reservada, "ADD");
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "DROP")){
            ReadNextTokenElement(Tokens.Reservada, "DROP");
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement("ADD", Tokens.Reservada));
            elementos.add(new TokenElement("DROP", Tokens.Reservada));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void AlterColumna4(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "ROWGUIDCOL")){
            ReadNextTokenElement(Tokens.Reservada, "ROWGUIDCOL");
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "NOT")){
            ReadNextTokenElement(Tokens.Reservada, "NOT");
            if(Error == null)
                ReadNextTokenElement(Tokens.Reservada, "FOR");
            if(Error == null)
                ReadNextTokenElement(Tokens.Reservada, "REPLICATION");
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement("ROWGUIDCOL", Tokens.Reservada));
            elementos.add(new TokenElement("NOT", Tokens.Reservada));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void AlterDrop(){
        ReadNextTokenElement(Tokens.Reservada, "DROP");
        if(Error == null)
            AlterDrop1();
        if(Error == null)
            AlterDrop2();
    }
    
    public void AlterDrop1(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "CONSTRAINT") || TokenActual.evaluarToken(Tokens.Reservada, "IF")
                || FirstID()){
            AlterDrop3();
            if(Error == null)
                IfExists();
            if(Error == null)
                ID();
        }
        else if(TokenActual.evaluarToken(Tokens.Reservada, "COLUMN")){
            ReadNextTokenElement(Tokens.Reservada, "COLUMN");
            if(Error == null)
                IfExists();
            if(Error == null)
                ID();
        }
        else{
            List<TokenElement> elementos = new ArrayList();
            elementos.add(new TokenElement("CONSTRAINT", Tokens.Reservada));
            elementos.add(new TokenElement("IF", Tokens.Reservada));
            elementos.add(new TokenElement("COLUMN", Tokens.Reservada));
            elementos.add(new TokenElement(null, Tokens.Identificador));
            elementos.add(new TokenElement("[", Tokens.Operador));
            TokenElement tok = new TokenElement(TokenActual.getID(), TokenActual.getNumLinea(), TokenActual.getPosInicial(), TokenActual.getPosFinal(), TokenActual.getValor(), TokenActual.getTok());
            Error = new SintaxisError(elementos, tok);
            salida.append(Error.getMensaje());
            salida.append("\n");
            Puntero = Puntero + BuscarFin(Puntero);
            TokenActual = ListaTokens.get(Puntero);
        }
    }
    
    public void AlterDrop2(){
        if(TokenActual.evaluarToken(Tokens.Operador, ",")){
            ReadNextTokenElement(Tokens.Operador, ",");
            if(Error == null)    
                AlterDrop4();
            if(Error == null)
                AlterDrop2();
        }
    }
    
    public void AlterDrop3(){
        if(TokenActual.evaluarToken(Tokens.Reservada, "CONSTRAINT")){
            ReadNextTokenElement(Tokens.Reservada, "CONSTRAINT");
        }
    }
    
    public void AlterDrop4(){
        if(FirstID()){
            
        }
        
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Analizador.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Analizador.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Analizador.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Analizador.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Analizador().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextArea TextArea1;
    private javax.swing.JButton btnAnalizar;
    private javax.swing.JButton btnBorrar;
    private javax.swing.JButton btnEntrada;
    private javax.swing.JButton btnGenerar;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JLabel lblRutaEntrada;
    // End of variables declaration//GEN-END:variables
}
